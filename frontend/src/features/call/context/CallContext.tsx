"use client";

import React, { createContext, useContext, useEffect, useRef, useState } from "react";
import { socketService } from "@/services/socket.service";
import { toast } from "sonner";

interface CallUser {
    id: string;
    name: string;
    avatar?: string;
}

type CallStatus = "idle" | "calling" | "ringing" | "active" | "ended";

interface CallContextType {
    status: CallStatus;
    initiateCall: (targetUserId: string, targetName: string, targetAvatar: string | null, type: "AUDIO" | "VIDEO") => void;
    acceptCall: () => void;
    rejectCall: () => void;
    endCall: () => void;
    incomingCall: { callerId: string; callerName: string; callerAvatar?: string; callId: string; type: "AUDIO" | "VIDEO" } | null;
    localStream: MediaStream | null;
    remoteStream: MediaStream | null;
    isMuted: boolean;
    isCameraOff: boolean;
    toggleMute: () => void;
    toggleCamera: () => void;
}

const CallContext = createContext<CallContextType | undefined>(undefined);

export const CallProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [status, setStatus] = useState<CallStatus>("idle");
    const [incomingCall, setIncomingCall] = useState<CallContextType["incomingCall"]>(null);
    const [currentCall, setCurrentCall] = useState<{ targetUserId: string; callId: string; type: "AUDIO" | "VIDEO" } | null>(null);

    const [localStream, setLocalStream] = useState<MediaStream | null>(null);
    const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);
    const [isMuted, setIsMuted] = useState(false);
    const [isCameraOff, setIsCameraOff] = useState(false);

    const pcRef = useRef<RTCPeerConnection | null>(null);
    const localStreamRef = useRef<MediaStream | null>(null);
    const ringtoneRef = useRef<HTMLAudioElement | null>(null);
    const dialtoneRef = useRef<HTMLAudioElement | null>(null);

    const pcConfig = {
        iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
        ],
    };

    useEffect(() => {
        // Initialize audio elements
        ringtoneRef.current = new Audio("https://assets.mixkit.co/active_storage/sfx/1359/1359-preview.mp3");
        ringtoneRef.current.loop = true;

        dialtoneRef.current = new Audio("https://assets.mixkit.co/active_storage/sfx/1233/1233-preview.mp3");
        dialtoneRef.current.loop = true;

        return () => {
            if (ringtoneRef.current) {
                ringtoneRef.current.pause();
                ringtoneRef.current = null;
            }
            if (dialtoneRef.current) {
                dialtoneRef.current.pause();
                dialtoneRef.current = null;
            }
        };
    }, []);

    const cleanup = () => {
        if (ringtoneRef.current) ringtoneRef.current.pause();
        if (dialtoneRef.current) dialtoneRef.current.pause();
        if (pcRef.current) {
            pcRef.current.close();
            pcRef.current = null;
        }
        if (localStreamRef.current) {
            localStreamRef.current.getTracks().forEach(track => track.stop());
            localStreamRef.current = null;
        }
        setLocalStream(null);
        setRemoteStream(null);
        setStatus("idle");
        setIncomingCall(null);
        setCurrentCall(null);
    };

    const setupPeerConnection = (targetUserId: string, callId: string) => {
        const pc = new RTCPeerConnection(pcConfig);

        pc.onicecandidate = (event) => {
            if (event.candidate) {
                socketService.send("webrtc:ice-candidate", {
                    callId,
                    targetUserId,
                    candidate: event.candidate
                });
            }
        };

        pc.ontrack = (event) => {
            setRemoteStream(event.streams[0]);
        };

        if (localStreamRef.current) {
            localStreamRef.current.getTracks().forEach(track => {
                pc.addTrack(track, localStreamRef.current!);
            });
        }

        pcRef.current = pc;
        return pc;
    };

    const initiateCall = async (targetUserId: string, targetName: string, targetAvatar: string | null, type: "AUDIO" | "VIDEO") => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: true,
                video: type === "VIDEO"
            });
            localStreamRef.current = stream;
            setLocalStream(stream);

            setStatus("calling");
            if (dialtoneRef.current) dialtoneRef.current.play().catch(e => console.log("Audio play deferred", e));
            // Call ID will be generated by server or here. Let's send initial event.
            socketService.send("call:initiate", { targetUserId, callType: type });

            toast.info(`Calling ${targetName}...`);
        } catch (err) {
            console.error("Failed to get media stream", err);
            toast.error("Could not access camera/microphone");
        }
    };

    const acceptCall = async () => {
        if (!incomingCall) return;

        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: true,
                video: incomingCall.type === "VIDEO"
            });
            localStreamRef.current = stream;
            setLocalStream(stream);

            const pc = setupPeerConnection(incomingCall.callerId, incomingCall.callId);
            setStatus("active");
            socketService.send("call:accept", {
                callId: incomingCall.callId,
                callerId: incomingCall.callerId,
                callType: incomingCall.type
            });
            setCurrentCall({
                targetUserId: incomingCall.callerId,
                callId: incomingCall.callId,
                type: incomingCall.type
            });
            setIncomingCall(null);
        } catch (err) {
            console.error("Failed to accept call", err);
            toast.error("Media access denied");
            rejectCall();
        }
    };

    const rejectCall = () => {
        if (incomingCall) {
            socketService.send("call:reject", {
                callId: incomingCall.callId,
                callerId: incomingCall.callerId,
                reason: "DECLINED",
                callType: incomingCall.type
            });
            cleanup();
        }
    };

    const endCall = () => {
        if (currentCall) {
            socketService.send("call:end", {
                callId: currentCall.callId,
                targetUserId: currentCall.targetUserId,
                callType: currentCall.type
            });
        }
        cleanup();
    };

    useEffect(() => {
        socketService.on("call:incoming", (data: any) => {
            if (status !== "idle") {
                socketService.send("call:reject", {
                    callId: data.callId,
                    callerId: data.callerId,
                    reason: "BUSY",
                    callType: data.callType
                });
                return;
            }
            setIncomingCall(data);
            setStatus("ringing");
            if (ringtoneRef.current) ringtoneRef.current.play().catch(e => console.log("Audio play deferred", e));
        });

        socketService.on("call:accepted", async (data: any) => {
            if (dialtoneRef.current) dialtoneRef.current.pause();
            if (!localStreamRef.current || !pcRef.current) {
                // We need to set up PC if it wasn't already (usually it is for the caller)
                // In initiateCall we haven't set up PC yet because we wait for callId or accepted.
                // Let's fix that.
            }
            // For the caller:
            const pc = setupPeerConnection(data.callerId || currentCall?.targetUserId, data.callId);
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            socketService.send("webrtc:offer", {
                callId: data.callId,
                targetUserId: data.callerId || currentCall?.targetUserId,
                sdp: offer
            });
            setStatus("active");
        });

        socketService.on("webrtc:offer", async (data: any) => {
            const pc = pcRef.current;
            if (!pc) return;

            await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);

            socketService.send("webrtc:answer", {
                callId: data.callId,
                targetUserId: data.senderId,
                sdp: answer
            });
        });

        socketService.on("webrtc:answer", async (data: any) => {
            const pc = pcRef.current;
            if (pc) {
                await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            }
        });

        socketService.on("webrtc:ice-candidate", async (data: any) => {
            const pc = pcRef.current;
            if (pc) {
                await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
        });

        socketService.on("call:rejected", (data: any) => {
            toast.error(`Call rejected: ${data.reason}`);
            cleanup();
        });

        socketService.on("call:ended", () => {
            toast.info("Call ended");
            cleanup();
        });

        socketService.on("error", (data: any) => {
            if (data.code === 'RATE_LIMIT_EXCEEDED') {
                toast.error(data.message);
                cleanup();
            }
        });

        return () => {
            socketService.off("call:incoming", () => { });
            socketService.off("call:accepted", () => { });
            socketService.off("webrtc:offer", () => { });
            socketService.off("webrtc:answer", () => { });
            socketService.off("webrtc:ice-candidate", () => { });
            socketService.off("call:rejected", () => { });
            socketService.off("call:ended", () => { });
        };
    }, [status, currentCall]);

    const toggleMute = () => {
        if (localStream) {
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !track.enabled;
            });
            setIsMuted(!isMuted);
        }
    };

    const toggleCamera = () => {
        if (localStream) {
            localStream.getVideoTracks().forEach(track => {
                track.enabled = !track.enabled;
            });
            setIsCameraOff(!isCameraOff);
        }
    };

    return (
        <CallContext.Provider value={{
            status, initiateCall, acceptCall, rejectCall, endCall, incomingCall,
            localStream, remoteStream, isMuted, isCameraOff, toggleMute, toggleCamera
        }}>
            {children}
        </CallContext.Provider>
    );
};

export const useCall = () => {
    const context = useContext(CallContext);
    if (!context) throw new Error("useCall must be used within a CallProvider");
    return context;
};
